# Lösungswege zu den Aufgaben für Einsteiger:innen {#sec-LoesungAnfang}

::: {.callout-warning appearance="simple"}
Gerade als Anfänger:in sollten Sie zumindest *versuchen*, die Aufgaben selbstständig zu lösen, bevor Sie sich die Lösungswege anschauen. Kopf hoch, Sie schaffen das!
:::

## Lösungen zu Objekten in R {#sec-LoesungenAnfangA}

### Lösung zur Aufgabe [-@sec-AAA00] Vektoren {#sec-LAA00}
::: {.callout-tip}
## R als Taschenrechner

```{r}
#| label: LoesungAA00a
# a)
(15.4 + 0.2) * (7-10.2) / 9

# b)
5/10 + 11/7 - 8/3

# c)
(13+2)^3 * (17-8)^2 / 9

# d)
sqrt( ((1+3)*25) / (5*5-15)^2 )
```

:::




### Lösung zur Aufgabe [-@sec-AAA01] Vektoren {#sec-LAA01}
::: {.callout-tip}
## a) Erzeugen Sie mit möglichst wenig Aufwand einen Datenvektor aus den Zahlen 1 bis 100.

```{r}
#| label: LoesungAA01a
zahlen <- c(1:100)
#anschauen
zahlen
```

:::


::: {.callout-tip}
## b) Erzeugen Sie einen Datenvektor, der aus den Wörtern "Apfel", "Birne" und "Postauto" besteht.

```{r}
#| label: LoesungAA01b
worte <- c("Apfel", "Birne", "Postauto")
# anschauen
worte
```

:::

::: {.callout-tip}
## c) Erzeugen Sie einen weiteren Datenvektor, in welchem die Wörter "Apfel", "Birne" und "Postauto" 30 mal wiederholt werden.

```{r}
#| label: LoesungAA01c
# mit rep() 30mal "worte" wiederholen
worte30 <- rep(worte, 30)
# anschauen
worte30
```

:::



### Lösung zur Aufgabe [-@sec-AAA02] Zufallsvektoren {#sec-LAA02}

::: {.callout-tip}
## a) Erzeugen Sie einen Datenvektor aus 200 zufälligen Zahlen zwischen 1 und 500, ohne dass eine Zahl doppelt vorkommt (sog. "ohne zurücklegen").

```{r}
#| label: LoesungAA02a
sample(1:500, 200, replace = FALSE)
```

:::


::: {.callout-tip}
## b) Erzeugen Sie einen weiteren Datenvektor mit ebenfalls 200 zufälligen Zahlen zwischen 1 und 500, wobei Zahlen nun doppelt vorkommen dürfen (sog. "mit zurücklegen").

```{r}
#| label: LoesungAA02b
sample(1:500, 200, replace = TRUE)
```

:::




### Lösung zur Aufgabe [-@sec-AAA03] Krankenhausaufenthalte {#sec-LAA03}

::: {.callout-tip}
## a) Überführen Sie die Daten in ein R-Objekt mit dem Namen `KHAufenthalte`.

```{r}
#| label: LoesungAA03a
KHAufenthalte <- c(1,0,0,3,1,5,1,2,2,0,1,0,5,2,1,0,1,0,0,4,0,1,1,3,0,
                   1,1,1,3,1,0,1,4,2,0,3,1,1,7,2,0,2,1,3,0,0,0,0,6,1,
                   1,2,1,0,1,0,3,0,1,3,0,5,2,1,0,2,4,0,1,1,3,0,1,2,1,
                   1,1,1,2,2,0,3,0,1,0,1,0,0,0,5,0,4,1,2,2,7,1,3,1,5)
#anschauen
KHAufenthalte
```
:::

::: {.callout-tip}
## b) Entfernen Sie den ersten und den dritten Eintrag aus Ihrem R-Objekt.

```{r}
#| label: LoesungAA03b
# ersten und dritten Wert enfernen
KHAufenthalte <- KHAufenthalte[-c(1,3)]

#anschauen
KHAufenthalte
```
:::


::: {.callout-tip}
## c) Fügen Sie die Werte $7$ und $2$ dem Objekt hinzu.

```{r}
#| label: LoesungAA03c
# 7 und 2 hinzufügen
KHAufenthalte <- c(KHAufenthalte, 7, 2)

#anschauen
KHAufenthalte
```
:::

::: {.callout-tip}
## d) Benennen Sie das Objekt in `hospital.stays` um.

```{r}
#| label: LoesungAA03d
# umbenennen
hospital.stays <- KHAufenthalte
```
:::

::: {.callout-tip}
## e) Klassieren Sie mit der `cut()`-Funktion in die Klassen $0$, $1-2$ und $>2$ Aufenthalte.

```{r}
#| label: LoesungAA03e
# cut
cut(hospital.stays, breaks=c(0,1,3,Inf), right=FALSE)

# mit custom labels
cut(hospital.stays, breaks=c(0,1,3,Inf), right=FALSE,
    labels=c("0", "1-2", "mehr als 2"))
```
:::






### Lösung zur Aufgabe [-@sec-AAA04] Größe und Gewicht {#sec-LAA04}

::: {.callout-tip}
## a) Überführen Sie die Daten in R-Objekte mit den Namen `Groesse` und `Gewicht`.

```{r}
#| label: LoesungAA04a
Groesse <- c(1.68, 1.87, 1.95, 1.74, 1.80,
             1.75, 1.59, 1.77, 1.82, 1.74)

Gewicht <- c(78500, 110100, 97500, 69200, 82500,
             71500,  81500, 87200, 75500, 65500)

# anzeigen
Groesse
Gewicht
```
:::

::: {.callout-tip}
## b) Rechnen Sie das Gewicht um in Kilogramm, und speichern Sie Ihr Ergebnis in der Variable `Kilogramm`.

```{r}
#| label: LoesungAA04b
# Rechne Gramm in Kilogramm um 
Kilogramm <-  Gewicht/1000

# anzeigen
Kilogramm
```
:::


::: {.callout-tip}
## c) Berechnen Sie den BMI (kg/m^2^) der Probanden und speichern Ihr Ergebnis in das Objekt `BMI`.

```{r}
#| label: LoesungAA04c
# BMI berechnen 
BMI <-  Kilogramm / (Groesse^2)

# anzeigen
BMI
```
:::


::: {.callout-tip}
## d) Fügen Sie die Objekte `Groesse`, `Gewicht` (aber in Kilogramm) und `BMI` zu einem Datenframe zusammen.

```{r}
#| label: LoesungAA04d
# Datenframe erzeugen
df <- data.frame(Groesse, Gewicht=Kilogramm, BMI)

# anzeigen
df
```
:::



::: {.callout-tip}
## e) Lassen Sie die Daten von Proband 4, 7 und 9 ausgeben.

```{r}
#| label: LoesungAA04e
df[c(4, 7, 9),]
```
:::



::: {.callout-tip}
## f) Lassen Sie die Daten der Probanden ausgeben, deren Gewicht größer ist als 80kg.

```{r}
#| label: LoesungAA04f
df[df$Gewicht > 80 , ]
```
:::







### Lösung zur Aufgabe [-@sec-AAA05] ordinale Faktoren {#sec-LAA05}

::: {.callout-tip}
## a) Erstellen Sie die ordinale Variable `Monate`, in welcher die 12 ausgeschriebenen Monatsnamen in korrekter Levelreihenfolge enthalten sind.

```{r}
#| label: LoesungAA05a
# ordinaler Faktor
Monate <- factor(c("Januar", "Februar", "März", "April", "Mai", "Juni",
                 "Juli", "August", "September", "Oktober", "November",
                 "Dezember"), 
                 levels= c("Januar", "Februar", "März", "April", "Mai", 
                           "Juni", "Juli", "August", "September", "Oktober", 
                           "November", "Dezember"),
                 ordered=TRUE )

# anzeigen  
Monate
```

Wir können uns aber auch ein bisschen Schreibarbeit ersparen.
```{r}
#| label: LoesungAA05a2
# Hilfsvektor erzeugen
dummy <- c("Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", 
           "August", "September", "Oktober", "November", "Dezember")
# ordinaler Faktor
Monate <- factor(dummy, levels=dummy, ordered=TRUE)

# anzeigen  
Monate
```

:::




::: {.callout-tip}
## b) Erstellen Sie die ordinale Variable `Schulnoten`, in welcher die 6 ausgeschriebenen Schulnoten  in korrekter Levelreihenfolge  enthalten sind.

```{r}
#| label: LoesungAA05b
# ordinaler Faktor
# Achten Sie auf die Reihenfolge der Schulnoten,
# wir müssen mit der schlechtesten anfangen.
Schulnoten <- c("ungenügend", "mangelhaft", "ausreichend", "befriedigend",
                "gut", "sehr gut")
Schulnoten <- factor(Schulnoten, levels=Schulnoten, ordered=TRUE)

# anzeigen
Schulnoten
```

:::


::: {.callout-tip}
## c) Erzeugen Sie einen ordinalen Factor `woche`, welcher die Wochentagen von Montag bis Sonntag mit korrekter Levelreihenfolge enthält.

Um etwas Schreibarbeit zu sparen, schreiben wir die Tage in ein eigenes Objekt. Dieses kann dann für `factor()` und `levels` genutzt werden.
```{r}
#| label: LoesungAA05c
# Tage in Objekt speichern
tage <- c("Montag", "Dienstag", "Mittwoch", 
          "Donnerstag", "Freitag", "Samstag", "Sonntag")
# Dieses Objekt dann wiederverwenden
woche <- factor(tage, 
                ordered = TRUE,
                levels=tage) 
# anzeigen
woche
```

:::

::: {.callout-tip}
## d) Ändern Sie die Levelnamen so um, dass nun die Wochentage in englischer Sprache (Monday to Sunday) enthalten sind.

```{r}
#| label: LoesungAA05d
levels(woche) <- c("Monday", "Tuesday", "Wednesday", "Thursday", 
                   "Friday", "Saturday", "Sunday")
# anzeigen
woche
```

:::

::: {.callout-tip}
## e) Erzeugen Sie aus den folgenden Daten einen ordinalen Faktor mit korrekter Levelreihenfolge

```{r}
#| label: LoesungAA05e
# ordinaler Faktor
f <- factor(c("vielleicht", "glaube nicht", "nein", "glaube nicht", 
              "ja", "glaube schon", "vielleicht", "nein", "glaube nicht",
              "ja", "ja", "glaube schon", "ja", "ja", "nein", 
              "glaube nicht", "glaube schon", "vielleicht", "vielleicht", 
              "glaube nicht", "vielleicht", "glaube nicht", "nein", 
              "glaube nicht", "ja", "glaube schon", "vielleicht", "nein", 
              "glaube nicht", "ja", "ja", "glaube schon", "ja", "ja", 
              "nein", "glaube nicht", "glaube schon", "vielleicht", 
              "vielleicht", "glaube nicht"),
            levels=c("nein", "glaube nicht", "vielleicht", "glaube schon", "ja"), 
            ordered=TRUE)
# anzeigen
f
```

:::



::: {.callout-tip}
## f) Ändern Sie die Levelnamen in `-2`, `-1`, `0`, `1`, `2`.

```{r}
#| label: LoesungAA05f
# Levelnamen ändern
levels(f) <- c("-2", "-1", "0", "1", "2")

# anzeigen
f
```

:::




### Lösung zur Aufgabe [-@sec-AAA05B] kleines Datenframe {#sec-LAA05B}

::: {.callout-tip}
## a) Erstellen Sie ein Dataframe mit den Spalten "`Name`", "`Alter`" und "`Geschlecht`" und fügen Sie drei Beispielzeilen mit Daten hinzu.

```{r}
#| label: LoesungAA05Ba
df <- data.frame(Name = c("Max", "Lisa", "Tom"),
                 Alter = c(22, 25, 30),
                 Geschlecht = factor(c("m", "w", "m")))
# anzeigen
df
```

:::


::: {.callout-tip}
## b) Fügen Sie eine neue Spalte "`Hobbys`" hinzu und füllen Sie diese mit drei Beispielwerten.

```{r}
#| label: LoesungAA05Bb
df$Hobbys <- c("Sport", "Musik", "Reisen")

# anzeigen
df
```

:::



::: {.callout-tip}
## c) Die zweite Person heisst Kunigunde

```{r}
#| label: LoesungAA05Bc
df$Name[2] <- "Kunigunde"

# anzeigen
df
```

:::



\newpage


### Lösung zur Aufgabe [-@sec-AAA05C] Studiengänge {#sec-LAA05C}

::: {.callout-tip}
## a) Erstellen Sie das Datenframe `Studiengaenge` mit den Variablen "`Fachbereich`", "`Studiengang`" und "`Niveau`" (Bachelor/Master), und überführen Sie die oben stehenden Daten in das Datenframe.

```{r}
#| label: LoesungAA05Ca
# FB06 und FB10 haben jeweils 6 Studiengänge
# schreibe direkt als factor()
Fachbereich <- factor(c("FB06", "FB06", "FB06", "FB06", "FB06", "FB06", 
                 "FB10", "FB10", "FB10", "FB10", "FB10", "FB10"))
## oder auch so:
Fachbereich <- factor(c(rep("FB06", 6), rep("FB10", 6)))

# Zuerst die Studiengänge von FB06, dann von FB10
# schreibe direkt als factor()
Studiengang = factor(c("BA  Soziale Arbeit", "BA Kulturpädagogik", 
                "BA Kindheitspädagogik", "MA Soziale Arbeit", 
                "MA Kulturpädagogik & Kulturmanagement", 
                "MA Sozialmanagement", "BA Health Care Management",
                "BA Medizinische Informatik", 
                "BA Angewandte Therapiewissenschaften", "BA Pflege",
                "BA Angewandte Hebammenwissenschaft", "MA Health Care"))

# FB06 hat 3xBachelor und 3xMaster, FB010 hat 5xBachelor und 1xMaster
Niveau = factor(c("Bachelor", "Bachelor", "Bachelor", "Master", "Master", 
                  "Master", "Bachelor", "Bachelor", "Bachelor", "Bachelor", 
                  "Bachelor", "Master"))
# oder auch so:
Niveau = factor(c(rep("Bachelor", 3), rep("Master", 3), 
                  rep("Bachelor", 5), "Master"))

# Füge zu Datenframe zusammen
Studiengaenge <- data.frame(Fachbereich,
                            Studiengang,
                            Niveau)

# anzeigen
Studiengaenge
```

:::




### Lösung zur Aufgabe [-@sec-AAA06] Hogwarts-Kurse {#sec-LAA06}

::: {.callout-tip}
## a) Erstellen Sie das Datenframe `Kurse`, in welchem die Daten aus den Tabellenspalten `Haus` und `Kurs` enthalten sind.

```{r}
#| label: LoesungAA06a
# Daten übertragen
Kurse <- data.frame(
  Haus = c("Gryffindor", "Gryffindor", "Gryffindor", "Gryffindor",
           "Hufflepuff", "Hufflepuff", "Hufflepuff", "Hufflepuff",
           "Ravenclaw", "Ravenclaw", "Ravenclaw", "Ravenclaw",
           "Slytherin", "Slytherin", "Slytherin", "Slytherin"),
  Kurs = c("Verteidigung gegen die dunklen Künste", "Zauberkunst", 
           "Verwandlung", "Besenflugunterricht",
           "Kräuterkunde", "Pflege magischer Geschöpfe", 
           "Geschichte der Zauberei", "Alte Runen",
           "Arithmantik", "Astronomie", 
           "Verwandlung", "Verteidigung gegen die dunklen Künste",
           "Zaubertränke", "Zauberkunst", 
           "Dunkle Künste", "Legilimentik")
)
# anzeigen  
Kurse
```
:::


::: {.callout-tip}
## b) Wieviele Kurse haben es in die Auswahlliste geschafft?


```{r}
#| label: LoesungAA06b1
# unique()
unique(Kurse$Kurs)
length(unique(Kurse$Kurs))

```
Es sind 13 Kurse in der Liste.
:::


::: {.callout-tip}
## c) Erstellen Sie für jedes Haus ein eigenes Datenframe

```{r}
#| label: LoesungAA06c
# Subsets erstellen
gryffindor <- subset(Kurse, Haus=="Gryffindor")
hufflepuff <- subset(Kurse, Haus=="Hufflepuff")
ravenclaw <- subset(Kurse, Haus=="Ravenclaw")
slytherin <- subset(Kurse, Haus=="Slytherin")
```

:::

::: {.callout-tip}
## d) Wandeln Sie in jedem Haus-Datenframe die Variablen in Faktoren um.

```{r}
#| label: LoesungAA06d
# Subsets erstellen
gryffindor$Kurs <- factor(gryffindor$Kurs)
gryffindor$Haus <- factor(gryffindor$Haus)

hufflepuff$Kurs <- factor(hufflepuff$Kurs)
hufflepuff$Haus <- factor(hufflepuff$Haus)

ravenclaw$Kurs <- factor(ravenclaw$Kurs)
ravenclaw$Haus <- factor(ravenclaw$Haus)

slytherin$Kurs <- factor(slytherin$Kurs)
slytherin$Haus <- factor(slytherin$Haus)
```

:::


::: {.callout-tip}
## e) Fügen Sie die Haus-Datenframes zu einem einzigen Datenframe `Hogwarts` zusammen, in der Reihenfolge Ravenclaw, Gryffindor, Syltherin und Hufflepuff. Ändern Sie anschließend den Kurs "*Geschichte der Zauberei*" in "*Geisterkunde*" um. 

```{r}
#| label: LoesungAA06e
# Zusammenführen
Hogwarts <- rbind(ravenclaw, gryffindor, slytherin, hufflepuff)

# Level ändern
levels(Hogwarts$Kurs)[levels(Hogwarts$Kurs)=="Geschichte der Zauberei"] <- "Geisterkunde"

# anzeigen
Hogwarts$Kurs
```

:::



::: {.callout-tip}
## f) Sortieren Sie den Datensatz, so dass die Kurse in alphabetischer Reihenfolge angezeigt werden.

Wenn wir "einfach so" die `order()`-Funktion nutzen, erhalten wir eine falsche Ausgabe.
```{r}
#| label: LoesungAA06f
# wird nicht korrekt sortiert
Hogwarts[order(Hogwarts$Kurs),]
```
Das liegt daran, dass `Hogwarts$Kurs` als Factor vorliegt, und somit nach Levelreihenfolge sortiert wird.

```{r}
#| label: LoesungAA06f2
# Datenklasse Factor
class(Hogwarts$Kurs)
```

Wir müssen daher die Funktion `as.character()` um die Variable wickeln, um eine alphabetische Sortierung zu erzwingen.

```{r}
#| label: LoesungAA06f3
# jetzt klappt es
Hogwarts[order(as.character(Hogwarts$Kurs)),]
```

:::


::: {.callout-tip}
## g) Speichern Sie den so sortierten Datensatz in das Objekt `sorted`, und reparieren Sie die Zeilennummerierung von `sorted`.

```{r}
#| label: LoesungAA06g
# sortiert speichern
sorted <- Hogwarts[order(as.character(Hogwarts$Kurs)),]

# Zeilennummerierung reparieren
rownames(sorted) <- 1:length(sorted$Kurs)

# anzeigen
sorted
```

:::







### Lösung zur Aufgabe [-@sec-AAA07] Datentabelle {#sec-LAA07}

::: {.callout-tip}
## a) Übertragen Sie die Daten in das Datenframe `chol`.

```{r}
#| label: LoesungAA07a
# Daten übertragen
chol <- data.frame(Name = c("Anna Tomie", "Bud Zillus", "Dieter Mietenplage",
                            "Hella Scheinwerfer", "Inge Danken", "Jason Zufall"),
                   Geschlecht = c("W", "M", "M", "W", "W", "M"),
                   Gewicht = c(85, 115, 79, 60, 57, 96),
                   Größe = c(179, 173, 181, 170, 158, 174),
                   Cholesterol = c(182, 232, 191, 200, 148, 249)
        )
# anzeigen  
chol
```
:::


::: {.callout-tip}
## b) Erstellen Sie eine neue Variable `Alter`, die zwischen `Name` und `Geschlecht` liegt

```{r}
#| label: LoesungAA07b
# Daten übertragen
alter <- c(18, 32, 24, 35, 46, 68)

# zwischen Name und Geschlecht einfügen
chol <- data.frame(Name=chol$Name, Alter=alter, Geschlecht=chol$Geschlecht, 
                   Gewicht=chol$Gewicht, Größe=chol$Größe, 
                   Cholesterol=chol$Cholesterol)
# anzeigen  
chol
```
:::



::: {.callout-tip}
## c) Fügen Sie einen weiteren Fall mit folgenden Daten dem Datenframe hinzu.

```{r}
#| label: LoesungAA07c
# Daten übertragen
neu <- data.frame(Name="Mitch Mackes", Alter=44, Geschlecht="M", Gewicht=92,
                  Größe=178, Cholesterol=220)

# zusammenfügen
chol <- rbind(chol, neu)
# anzeigen  
chol
```
:::


::: {.callout-tip}
## d) Erzeugen Sie eine neue Variable `BMI` ($\text{BMI}=\frac{kg}{m^2}$).

```{r}
#| label: LoesungAA07d
# BMI hinzufügen
# Größe muss in Meter umgerechnet werden
chol$BMI <- chol$Gewicht / (chol$Größe/100)^2

# anzeigen  
chol
```
:::




::: {.callout-tip}
## e) Fügen Sie die Variable `Adipositas` hinzu, in welcher Sie die `BMI`-Werte klassieren

Ein Klassierung kann auf mehrere Weisen erfolgen.
```{r}
#| label: LoesungAA07e
# bedingtes Referenzieren
chol$Adipositas[chol$BMI < 18.5] <- "Untergewicht"
chol$Adipositas[chol$BMI >= 18.5 & chol$BMI < 24.5] <- "Normalgewicht"
chol$Adipositas[chol$BMI >= 24.5 & chol$BMI < 30] <- "Übergewicht"
chol$Adipositas[chol$BMI >= 30]   <- "Adipositas"

# anzeigen  
chol
```

Alternativ kann die `cut()`-Funktion verwendet werden.
```{r}
#| label: LoesungAA07e2
# cut-Funktion
chol$Adipositas <- cut(chol$BMI, breaks = c(0, 18.5, 24.5, 30, Inf), 
                       labels = c("Untergewicht", "Normalgewicht", 
                                  "Übergewicht", "Adipositas"),
                       right = FALSE)

# anzeigen  
chol
```
:::




::: {.callout-tip}
## f) Filtern Sie Ihren Datensatz, so dass Sie einen neuen Datensatz `male` erhalten, welcher nur die Daten der Männer beinhaltet.

```{r}
#| label: LoesungAA07f
# subset erzeugen
male <- subset(chol, Geschlecht=="M")

# anzeigen  
male
```

:::







### Lösung zur Aufgabe [-@sec-AAA08] Zusatzpaket {#sec-LAA08}

::: {.callout-tip}
## a) Installieren Sie das Zusatzpaket `jgsbook` mit allen Abhängigkeiten

```{r}
#| label: LoesungAA08a
#| eval: false
# installiere inkl Abhängigkeiten
install.packages("jgsbook", dependencies = TRUE)
```
:::

::: {.callout-tip}
## b) Welche Datensätze sind in dem Paket enthalten?

Der folgende Befehl öffnet einen neuen Tab in RStudio:
```{r}
#| label: LoesungAA08b
#| eval: false
# Zeige die enthaltenen Datensätze graphisch an
data(package = "jgsbook")
```

Für die Ausgabe auf der Konsole können wir so vorgehen.
```{r}
#| label: LoesungAA08b2
#| eval: true
# Zeige die enthaltenen Datensätze auf Konsole
a <- data(package = "jgsbook")
as.data.frame(a$results[, 3:4])
```
:::



::: {.callout-tip}
## c) Speichern Sie den Datensatz `pf8` aus dem `jgsbook` in das Objekt `df`. Welche Variablen sind im Datensatz enthalten?

```{r}
#| label: LoesungAA08c
df <- jgsbook::pf8

# anzeigen
str(df)
```
:::


::: {.callout-tip}
## d) Rufen Sie Dokumentation für das `jgsbook`-Paket auf.

```{r}
#| label: LoesungAA08d
help(package = "jgsbook")
```
:::


::: {.callout-tip}
## e) Wenden Sie die Funktion `freqTable()` aus dem Paket `jgsbook` auf die Variable `df$Kinder` an, **ohne** das Paket vorher per `library()` zu aktivieren.

```{r}
#| label: LoesungAA08e
# Funktion aufrufen ohne Paket zu laden
jgsbook::freqTable(df$Kinder)
```
:::


### Lösung zur Aufgabe [-@sec-AAA09] Daten laden {#sec-LAA09}

::: {.callout-tip}
## a) `Datentabelle.txt`

```{r}
#| label: LoesungAA09a
#| eval: false
# Lese Daten ein
a <- read.table("https://www.produnis.de/trainingslager/data/Datentabelle.txt", header=TRUE)
```

```{r}
#| label: LoesungAA09a2
#| include: false
a <- read.table("data/Datentabelle.txt", header=TRUE)
```

```{r}
#| label: LoesungAA09a3
# Datenklassen anschauen
str(a)

# Geschlecht anpassen
a$Geschlecht <- factor(a$Geschlecht)

# anschaeun
str(a)
```
:::




::: {.callout-tip}
## b) `anwesenheitnoten.csv`

In der Datei werden Dezimalstellen mit "," und Feldtrenner mit ";" angegeben. Entsprechend lautet der Aufruf von `read.table()`:
```{r}
#| label: LoesungAA09b
#| eval: false
# Lese Daten ein
b <- read.table("https://www.produnis.de/trainingslager/data/anwesenheitnoten.csv", 
                header=TRUE, dec=",", sep=";")
```

```{r}
#| label: LoesungAA09b2
#| include: false
b <- read.table("data/anwesenheitnoten.csv", header=TRUE, dec=",", sep=";")
```

```{r}
#| label: LoesungAA09b3
# Datenklassen anschauen
str(b)

```
Alle Datenklassen sind korrekt (numerisch).
:::





::: {.callout-tip}
## c) `Testdatumdaten.xlsx`

```{r}
#| label: LoesungAA09d
#| eval: false
# Lese Daten ein
d <- openxlsx::read.xlsx("https://www.produnis.de/trainingslager/data/Testdatumdaten.xlsx")
```

```{r}
#| label: LoesungAA09d2
#| include: false
d <- readxl::read_excel("data/Testdatumdaten.xlsx")
```

```{r}
#| label: LoesungAA09d3
# Datenklassen anschauen
str(d)

# Datenklassen anpassen
d$Vornme <- factor(d$Vornme)
d$Geschlecht <- factor(d$Geschlecht)
d$Lieblingsfarbe <- factor(d$Lieblingsfarbe)
# Zeitformat
d$Geburtstag <- lubridate::dmy(d$Geburtstag, tz="CET")

# anschauen
str(d)
```
:::
































\newpage 

## Lösungen zur deskriptiven Statistik {#sec-LoesungenAnfangB}

### Lösung zur Aufgabe [-@sec-AAB00] Median Mittelwert {#sec-LAB00}
::: {.callout-tip}
## a) erzeugen Sie einen Datenvektor mit Werten von $1$ bis $10$

```{r}
#| label: LoesungAB00a
v <- 1:10
```

:::


::: {.callout-tip}
## b) berechnen Sie den Median und das arithmetische Mittel 

```{r}
#| label: LoesungAB00b
median(v)
mean(v)
```
:::


::: {.callout-tip}
## c) fügen Sie den Wert $45881$ dem Datenvektor hinzu

```{r}
#| label: LoesungAB00c
v <- c(v, 45881)
# anschauen
v
```
:::


::: {.callout-tip}
## d) berechnen Sie erneut den Median und das arithmetische Mittel. Was fällt Ihnen auf?

```{r}
#| label: LoesungAB00d
median(v)
mean(v)
```
Es fällt auf, dass der Mittelwert viel stärker von dem neuen Wert (45881) beinflusst wird als der Median.
:::




### Lösung zur Aufgabe [-@sec-AAB01] Serumcholesterin {#sec-LAB01}
::: {.callout-tip}
## a) Überführen Sie die Daten in ein Datenframe mit der Variable `chol`.

```{r}
#| label: LoesungAB01a
# gebe die Werte ein
serumchol <- c(4.5, 4.9, 7.3, 5.2, 5.8, 6.2, 5.0, 5.6, 6.4, 7.6,
               5.4, 4.4, 6.6, 5.3, 5.7, 4.7, 8.2, 6.7, 4.8, 5.9)


# erstelle Datenframe
df <- data.frame(chol= serumchol)
```

:::

::: {.callout-tip}
## b) Klassieren Sie die Serumcholesterinwerte.

Die Klassierung erfoglt entweder "von Hand":
```{r}
#| label: LoesungAB01b1
# erstelle Werteklassen in eigener Variablenspalte
df$cholklass[df$chol < 5] <- "4.0-4.9"                  # alle Werte kleiner 5
df$cholklass[df$chol < 6 & df$chol  > 4.9] <- "5.0-5.9" # Werte kleiner 6 und größer 4
df$cholklass[df$chol < 7 & df$chol  > 5.9] <- "6.0-6.9" # Werte kleiner 7 und größer 5
df$cholklass[df$chol < 8 & df$chol  > 6.9] <- "7.0-7.9" # Werte kleiner 8 und größer 6
df$cholklass[df$chol < 9 & df$chol  > 7.9] <- "8.0-8.9" # Werte kleiner 9 und größer 7
df$cholklass <- factor(df$cholklass, ordered=T)
# neue Variable anschauen
df$cholklass
```

...oder mittels `cut()`.
```{r}
#| label: LoesungAB01b2
df$cholklass2 <- cut(df$chol, breaks=c(4:9),
                     right=FALSE,
                     ordered_result = TRUE)
# anzeigen
df
```

:::



::: {.callout-tip}
## c) Erstellen Sie eine ausreichend beschriftete Häufigkeitstabelle mit nicht kumulierten und kumulierten absoluten und relativen Häufigkeiten für die Häufigkeiten in den zuvor erstellten Serumcholesterinklassen.

```{r}
#| label: LoesungAB01c
# erzeuge eine Häufigkeitstabelle
jgsbook::freqTable(df$cholklass)
```

:::


::: {.callout-tip}
## d) Bestimmen Sie bitte folgende Kenngrößen

```{r}
#| label: LoesungAB01d
# allgemein:
summary(df$chol)

# speziell
psych::describe(df$chol, 
                IQR=TRUE,
                skew=FALSE,
                quant = c(.10, 0.25, 0.75, .90)
                )
# Was fehlt noch:
# Varianz
var(df$chol)
# und Median
median(df$chol)
```

:::


::: {.callout-tip}
## e) Erstellen Sie einen Boxplot der Werte.

```{r}
#| label: LoesungAB01e
boxplot(df$chol)

# hübscher
boxplot(df$chol, main="Serumcholesterinspiegel in mmol/l",
        col="cyan", border="blue")
```
:::


::: {.callout-tip}
## f) Stellen Sie die in b) aufgelisteten absoluten nicht kumulierten Häufigkeiten als Histogramm dar.

```{r}
#| label: LoesungAB01f
# Histogram
hist(df$chol)

# Histogram mit 5 "breaks und etwas hübscher
hist(df$chol, breaks=5,
     col="skyblue2",
     main="Histogram",
     xlab="Serumcholesterin",
     ylab="Häufigkeit")

```
:::


::: {.callout-tip}
## g) Welche Form hat die Verteilung?

```{r}
#| label: LoesungAB01g
# "Schiefe" berechnen
psych::skew(df$chol)

# "Spitzigkeit" berechnen
psych::kurtosi(df$chol)
```

Die Skewness ist positiv, d.h. die Verteilung ist linksgipflig (aka rechtschief).

Die Kurtosis von -0,63 zeigt an, dass die Daten flacher und breiter als eine Normalverteilung sind.
:::




### Lösung zur Aufgabe [-@sec-AAB02] Gewichtsreduktion {#sec-LAB02}
::: {.callout-tip}
## a) Überführen Sie die Daten in ein Datenframe.

```{r}
#| label: LoesungAB02a
alter <- c(4,  7  ,8,  9,  11, 12, 13, 14, 15, 16, 16, 20, 20, 
           22, 25, 26, 26, 28, 29, 34)
geschlecht <- c(1, 2, 2, 2, 1, 1, 2, 2, 2, 1, 1, 2, 2, 2, 1, 0, 2, 1, 2, 0)

# Erzeuge Datenframe
df <- data.frame(alter, geschlecht)
```

:::


::: {.callout-tip}
## b) Kodieren Sie der Variable "`Geschlecht`" um

```{r}
#| label: LoesungAB02b

# wandle "Geschlecht"-Einträge um
df$geschlecht[df$geschlecht == "0"] <- "divers"
df$geschlecht[df$geschlecht == "1"] <- "männlich"
df$geschlecht[df$geschlecht == "2"] <- "weiblich"

# wandle in factor() um
df$geschlecht <- factor(df$geschlecht)

```

:::



::: {.callout-tip}
## c) Klassieren Sie das Alter der Probanden

Die Altersklassierung erfolgt entweder "von Hand"...
```{r}
#| label: LoesungAB02c
# klassiere die Daten in eigener Spaltenvariable
df$alterk[df$alter < 6] <- "0-5" # alle Werte kleiner 6 
df$alterk[df$alter < 11 & df$alter > 5] <- "6-10" # Werte kleiner 11 und größer 5
df$alterk[df$alter < 16 & df$alter > 10] <- "11-15" # Werte kleiner 16 und größer 10 
df$alterk[df$alter < 21 & df$alter > 15] <- "16-20" # Werte kleiner 21 und größer 15 
df$alterk[df$alter < 26 & df$alter > 20] <- "21-25" # Werte kleiner 26 und größer 20
df$alterk[df$alter < 31 & df$alter > 25] <- "26-30" # Werte kleiner 31 und größer 25
df$alterk[df$alter > 30] <- "31-35" # Werte größer 30 werden zu "31-35"

# ordinaler Faktor der Werteklassen
df$alterk <- factor(df$alterk,
                    levels=c("0-5", "6-10", "11-15", "16-20", "21-25", 
                             "26-30", "31-35"),
                    ordered=TRUE)
```

... oder per `cut()`-Funktion.
```{r}
#| label: LoesungAB02c2
df$alterk2 <- cut(df$alter, breaks = seq(0,35,by=5),
                            ordered=TRUE)
#anzeigen
df
```

:::



::: {.callout-tip}
## d) Bestimmen Sie folgende Stichprobenkennzahlen für das Merkmal '`Alter`'.

```{r}
#| label: LoesungAB02d
# allgemein
summary(df$alter)

# Minimum
min(df$alter)

# Perzentile und Quartile
quantile(df$alter, probs = c(0.05, 0.25, 0.75, 0.95))

# Perzentile und Quartile
# mit SPSS-Rechenmethode (type=6)
quantile(df$alter, probs = c(0.05, 0.25, 0.75, 0.95), type=6)

# Median
median(df$alter)

# ar.Mittel
mean(df$alter)

# Maximum
max(df$alter)

# Interquartilsabstand
IQR(df$alter)
# Interquartilsabstand
# SPSS-Rechenmethode (type=6)
IQR(df$alter, type=6)
```

Berechne (fast) alles auf einmal:
```{r}
#| label: LoesungAB02d2
# oder einfach
psych::describe(df$alter,
                quant = c(0.05, 0.25, 0.75, 0.95),
                skew=FALSE,
                IQR=TRUE)
```

:::



::: {.callout-tip}
## e) Zeichnen Sie ein Histogramm und ein Balkendiagramm für die nicht kumulierten absoluten Häufigkeiten zur Anzahl der Studienteilnehmer in den zuvor gebildeten Altersklassen.

Die Funktion `hist()` kann nur metrische Daten verarbeiten. Daher nehmen wir die Variable "`alter`" (und nicht "`alterk`") und stellen die Abstände auf 5 (Jahre).

```{r}
#| label: LoesungAB02e
# Histogram geht mit R-base hist() nur bei metrischen Daten!!
# Die Werteklassen können per "breaks"-Parameter angegeben werden.
hist(df$alter)

# etwas hübscher
hist(df$alter, breaks = 5, col="cyan",
     main="Histogram",
     xlab="Alter",
     ylab="Häufigkeit") # 5er-Schritte

```

Für das Balkendiagramm nutzen wir die Funktion `table()` auf die Variable "`alterk`".
```{r}
#| label: LoesungAB02e2
# Häufigkeitstabelle von "alterk"
table(df$alterk)

# Balkendiagramm
barplot(table(df$alterk), horiz = TRUE)

# etwas hübscher
barplot(table(df$alterk), horiz = TRUE,
        col=rainbow(7),
        main="Häufigkeiten der Altersklassen")
```

:::



::: {.callout-tip}
## f) Erstellen Sie eine Kontingenztafel zur gleichzeitigen Darstellung der beiden Merkmale `Altersgruppe` und `Geschlecht`.

```{r}
#| label: LoesungAB02f
# Kontingenztafel
# entweder mit table()
table(df$alterk, df$geschlecht)
# oder mit xtabs()
xtabs(~df$alterk+df$geschlecht)

# in Dezimal-Prozent
prop.table(table(df$alterk, df$geschlecht))

# in Prozent
prop.table(table(df$alterk, df$geschlecht))*100
```
:::


::: {.callout-tip}
## g) Stellen Sie die Häufigkeitsverteilung der beiden Merkmale `Altersgruppe` und `Geschlecht` in einer geeigneten Graphik dar.

Geeignet ist ein geschichtetes Barplot.
```{r}
#| label: LoesungAB02g
# Barplot
barplot(table(df$geschlecht, df$alterk))
# mit Legendenbox
barplot(table(df$geschlecht, df$alterk), legend.text = levels(df$geschlecht))

# hübscher
barplot(table(df$geschlecht, df$alterk),
        legend.text = levels(df$geschlecht),
        main="Altersklassen nach Geschlecht",
        col=c("orange", "skyblue", "pink")
        )

# variante "beside=TRUE"
barplot(table(df$geschlecht, df$alterk),
        legend.text = levels(df$geschlecht),
        beside = TRUE,
        col=c("orange", "skyblue", "pink")
        )
```
:::








### Lösung zur Aufgabe [-@sec-AAB03] Anscombe-Quartett {#sec-LAB03}
::: {.callout-tip}
## a) Laden Sie den Datensatz `anscombe` in Ihre R-Session. 

```{r}
#| label: LoesungAB03a
# Lade Datensatz
data("anscombe")

# anschauen
str(anscombe)
```

:::


::: {.callout-tip}
## b) Schreiben Sie die 4 Anscombe-Datensätze (`x1` bis `x4` und `y1` bis `y4`) in 4 neue Datenframes mit den Namen `Anscombe1` bis `Anscombe4`. Die enthaltenen Spalten sollten jeweils `x` und `y` heissen.

```{r}
#| label: LoesungAB03b
Anscombe1 <- data.frame(x=anscombe$x1, y=anscombe$y1)
Anscombe2 <- data.frame(x=anscombe$x2, y=anscombe$y2)
Anscombe3 <- data.frame(x=anscombe$x3, y=anscombe$y3)
Anscombe4 <- data.frame(x=anscombe$x4, y=anscombe$y4)

```

:::



::: {.callout-tip}
## c) Führen Sie für jedes Datenframe die Berechnungen von Anscombe durch (Mittelwert, Varianz, Korrelation und lineare Regression), wobei Sie Ihre Ergebnisse auf 2 Stellen runden sollen. 


```{r}
#| label: LoesungAB03c1
### Datensatz Anscombe1
# Mittelwert für x, gerundet auf 2 Stellen
round(mean(Anscombe1$x), 2)

# Varianz für x
round(var(Anscombe1$x), 2)

# Mittelwert für y
round(mean(Anscombe1$y), 2)

# Varianz für y
round(var(Anscombe1$y), 2)

# Korrelationskoeffizient
round(cor(Anscombe1$x, Anscombe1$y), 2)

# Regression
fit <- lm(Anscombe1$y ~ Anscombe1$x)
round(fit$coefficients, 2)

```



```{r}
#| label: LoesungAB03c2
### Datensatz Anscombe2
# Mittelwert für x, gerundet auf 2 Stellen
round(mean(Anscombe2$x), 2)

# Varianz für x
round(var(Anscombe2$x), 2)

# Mittelwert für y
round(mean(Anscombe2$y), 2)

# Varianz für y
round(var(Anscombe2$y), 2)

# Korrelationskoeffizient
round(cor(Anscombe2$x, Anscombe2$y), 2)

# Regression
fit <- lm(Anscombe2$y ~ Anscombe2$x)
round(fit$coefficients, 2)

```




```{r}
#| label: LoesungAB03c3
### Datensatz Anscombe3
# Mittelwert für x, gerundet auf 2 Stellen
round(mean(Anscombe3$x), 2)

# Varianz für x
round(var(Anscombe3$x), 2)

# Mittelwert für y
round(mean(Anscombe3$y), 2)

# Varianz für y
round(var(Anscombe3$y), 2)

# Korrelationskoeffizient
round(cor(Anscombe3$x, Anscombe3$y), 2)

# Regression
fit <- lm(Anscombe3$y ~ Anscombe3$x)
round(fit$coefficients, 2)

```



```{r}
#| label: LoesungAB03c4
### Datensatz Anscombe4
# Mittelwert für x, gerundet auf 2 Stellen
round(mean(Anscombe4$x), 2)

# Varianz für x
round(var(Anscombe4$x), 2)

# Mittelwert für y
round(mean(Anscombe4$y), 2)

# Varianz für y
round(var(Anscombe4$y), 2)

# Korrelationskoeffizient
round(cor(Anscombe4$x, Anscombe4$y), 2)

# Regression
fit <- lm(Anscombe4$y ~ Anscombe4$x)
round(fit$coefficients, 2)

```

:::




::: {.callout-tip}
## d) Erzeugen Sie die 4 Anscombe-Diagramme (Punktwolke und Regressionsgerade) mit der `plot()`-Funktion, und hübschen Sie die Plots mit etwas Farbe auf.


```{r}
#| label: LoesungAB03d
#| layout-ncol: 2
# Datensatz Anscombe1
plot(Anscombe1$x, Anscombe1$y,
     xlim = c(0,20),  xlab="x",
     ylim = c(0,13),  ylab="y",
     col="darkblue")
abline(lm(Anscombe1$y ~ Anscombe1$x), col="red")

# Datensatz Anscombe2
plot(Anscombe2$x, Anscombe2$y,
     xlim = c(0,20),  xlab="x",
     ylim = c(0,13),  ylab="y",
     col="darkblue")
abline(lm(Anscombe2$y ~ Anscombe2$x), col="red")

# Datensatz Anscombe3
plot(Anscombe3$x, Anscombe3$y,
     xlim = c(0,20),  xlab="x",
     ylim = c(0,13),  ylab="y",
     col="darkblue")
abline(lm(Anscombe3$y ~ Anscombe3$x), col="red")

# Datensatz Anscombe4
plot(Anscombe4$x, Anscombe4$y,
     xlim = c(0,20),  xlab="x",
     ylim = c(0,13),  ylab="y",
     col="darkblue")
abline(lm(Anscombe4$y ~ Anscombe4$x), col="red")
```

:::


::: {.callout-tip}
## e) Erzeugen Sie die 4 Anscombe-Diagramme mittels `ggplot()`, wobei alle 4 Diagramme mit einem Plotaufruf erzeugt werden sollen.  Dies geht am einfachsten, wenn der Datensatz im Tidy-Data-Format (long table) vorliegt.

```{r}
#| label: LoesungAB03e
## Tidy-Longtable erzeugen
# Gruppen separieren
Anscombe1 <- data.frame(x=anscombe$x1, y=anscombe$y1, Gruppe="Anscombe1")
Anscombe2 <- data.frame(x=anscombe$x2, y=anscombe$y2, Gruppe="Anscombe2")
Anscombe3 <- data.frame(x=anscombe$x3, y=anscombe$y3, Gruppe="Anscombe3")
Anscombe4 <- data.frame(x=anscombe$x4, y=anscombe$y4, Gruppe="Anscombe4")

# alles zusammenfügen
df <- rbind(Anscombe1, Anscombe2, Anscombe3, Anscombe4)

# anschauen
str(df)

# plotten
library(ggplot2)
ggplot(df) +
  aes(x=x, y=y) +
  xlim(0,20) +
  ylim(0,13) +
  geom_point(color="darkblue")+
  geom_smooth(method="lm", color="red", se=FALSE) +
  facet_wrap(~ Gruppe)
```

:::




### Lösung zur Aufgabe [-@sec-AAB04] Kinder und Wohnräume {#sec-LAB04}
::: {.callout-tip}
## a) Berechnen Sie den Korrelationskoeffizienten `r`

```{r}
#| label: LoesungAB04a
df <- data.frame(ehepaar = c(1:5),
                 kinder  = c(0, 2, 3, 0, 1),
                 raeume  = c(1, 4, 3, 2, 3))

# Korreltation nach Pearson
cor(df$kinder, df$raeume)
```

:::


::: {.callout-tip}
## b) Berechnen Sie die Regressionsgerade und erstellen Sie die Graphik dazu!

```{r}
#| label: LoesungAB04b
# regressionsmodelle immer in variable speichern
fit <- lm(raeume~kinder, data=df)

# Modellübersicht
summary(fit)

# regressionsmodell plotten
plot(raeume~kinder, data=df) # Punktwolke
abline(fit)                  # Regressionsgerade hinzufügen

# etwas hübscher
plot(raeume~kinder, data=df,
     col="skyblue",
     pch=16,
     main="Regressionsgerade",
     xlab="Anzahl Kinder",
     ylab="Anzahl Räume")
abline(fit, col="red")
```

:::





### Lösung zur Aufgabe [-@sec-AAB05] Kinder und Geschwister {#sec-LAB05}
::: {.callout-tip}
## a) Berechnen Sie den Korrelationskoeffizienten `r`

```{r}
#| label: LoesungAB05a
df <- data.frame(person = c(1:5),
                 kinder  = c(1,  0,  3,  2,  1),
                 geschwister  = c(0,  1,  4 , 1,  2))

# Korrelation                 
cor(df$kinder, df$geschwister)
```

:::

::: {.callout-tip}
## b) Berechnen Sie die Gleichung der Regressionsgeraden und erstellen Sie die Graphik dazu!

```{r}
#| label: LoesungAB05b
# regressionsmodelle immer in variable speichern
fit <- lm(geschwister~kinder, data=df)

# Modellübersicht
summary(fit)
```


Die Gleichung der Regressionsgeraden lautet $y = 0,3077\ + 0,9231\cdot x$.

```{r}
#| label: LoesungAB05b2
# regressionsmodell plotten
plot(geschwister~kinder, data=df) # Punktwolke
abline(fit)                  # Regressionsgerade hinzufügen

# etwas hübscher
plot(geschwister~kinder, data=df,
     col="skyblue",
     pch=16,
     main="Regressionsgerade",
     xlab="Anzahl Kinder",
     ylab="Anzahl Geschwister")
abline(fit, col="red")
```


:::




::: {.callout-tip}
## c) Was geschieht mit `r` und mit der Regressionsgeraden, falls Sie die Angaben der 3. Person streichen und dann die Auswertung wiederholen?

```{r}
#| label: LoesungAB05c
# dritte Person streichen
df <- df[-3,]

# Korrelation
cor(df$kinder, df$geschwister)

# Regression
fit <- lm(geschwister~kinder, data=df)

# Modellübersicht
summary(fit)

# etwas hübscher
plot(geschwister~kinder, data=df,
     col="skyblue",
     pch=16,
     main="Regressionsgerade",
     xlab="Anzahl Kinder",
     ylab="Anzahl Geschwister")
abline(fit, col="red")
```

Wenn die 3. Person aus dem Datensatz entfernt wird, kann kein Zusammenhang zwischen `geschwister` und `kinder` gezeigt werden (`r=0`). Die Regressionsgerade verläuft parallel zur X-Achse, so dass `Y` für jedes `X` gleich ist.
:::



\bigskip\ 


### Lösung zur Aufgabe [-@sec-AAB06] Tribble Tibble {#sec-LAB06}

```{r}
#| label: LoesungAB06Setup
# erstellen des Datensatzes mittels tribble()
library(tibble)
df <- tribble(
  ~Vorname, ~Geschlecht, ~Alter, ~Wohnort, ~Groesse, ~Gewicht, ~Rauchen,
  "Hannah", "weiblich", 25, "Berlin", 1.75, 65, FALSE,
  "Max", "maennlich", 30, "Hamburg", 1.85, 75, TRUE,
  "Sophia", "weiblich", 20, "Muenchen", 1.65, 55, FALSE,
  "Lukas", "maennlich", 35, "Frankfurt", 1.95, 85, TRUE,
  "Emma", "weiblich", 18, "Stuttgart", 1.70, 60, FALSE,
  "Jonas", "maennlich", 40, "Duesseldorf", 1.80, 70, TRUE,
  "Lea", "weiblich", 22, "Hannover", 1.60, 50, FALSE,
  "Jan", "divers", 28, "Nuernberg", 1.90, 80, TRUE,
  "Mia", "weiblich", 24, "Bremen", 1.73, 63, FALSE,
  "Luca", "maennlich", 33, "Gelsenkirchen", 1.88, 78, TRUE
)
```


::: {.callout-tip}
## a) Wandeln Sie mittels `mutate()` die Variablen `Geschlecht` und `Wohnort` in Faktoren um.

```{r}
#| label: LoesungAB06a
#| warning: false
library(dplyr)
df <- df %>%
  mutate(Geschlecht = factor(Geschlecht),
         Wohnort = factor(Wohnort))

# anzeigen 
glimpse(df)
```

:::



::: {.callout-tip}
## b) Verwenden Sie `filter()`, um nur die Fälle anzuzeigen, die Raucher sind.

```{r}
#| label: LoesungAB06b
df %>%
  filter(Rauchen == TRUE)
```

:::


::: {.callout-tip}
## c) Verwenden Sie `group_by()` und `summarise()`, um Mittelwert, Standardabweichung und Median der Variable  `Alter` für jedes Geschlecht zu berechnen.

```{r}
#| label: LoesungAB06c
df %>%
  group_by(Geschlecht) %>%
  summarise(MW = mean(Alter),
            SD = sd(Alter),
            Median = median(Alter))

```

:::

::: {.callout-tip}
## d) Verwenden Sie `arrange()`, um den Datensatz nach Wohnort in alphabetischer Reihenfolge zu sortieren.

```{r}
#| label: LoesungAB06d
df %>%
  arrange(Wohnort)
```

:::





### Lösung zur Aufgabe [-@sec-AAB07] Abschlussnoten {#sec-LAB07}

::: {.callout-tip}
## a) Überführen Sie die Daten in `R`

```{r}
#| label: LoesungAB07a
#| warning: false
# überführe in ordinalen Factor
noten <- factor(c("2", "2", "4+", "2", "2-", "durchgefallen", "2", "2-", "2+", 
                  "2+", "4", "2", "2", "3-", "2", "2", "1-", "2", "2", "4", 
                  "3+", "2-", "2-", "2+", "1+", "1", "2", "2+", "3+", "2-", 
                  "3-", "1-", "3", "1-", "4", "4+", "2", "3+", "3", "2-", "2", 
                  "1-", "3+", "1+", "3", "2", "durchgefallen", "2-", "1-", 
                  "2+", "3", "3+", "2-", "2+", "2+", "durchgefallen", "2-", 
                  "2+", "2+", "2+", "1", "1-", "2", "4", "1-", "1+", "3", "2+", 
                  "2-", "2+", "2-", "2-", "2-", "4", "3+", "1", "2-", 
                  "durchgefallen", "1", "2+", "2-", "2"),
                ordered=TRUE,
                levels = c("1+", "1", "1-", "2+", "2", "2-",
                           "3+", "3", "3-", "4+", "4", 
                           "durchgefallen")
                )
```

:::


::: {.callout-tip}
## b) erstellen Sie eine vollständige Häufigkeitstabelle, ohne dabei die Funktion `freqTable()` zu verwenden.

```{r}
#| label: LoesungAB07b
#| warning: false
# überführe in Datenframe
df <- as.data.frame(table(noten))

# kumuliere
df$Hkum <- cumsum(df$Freq)

# relative Häufigkeiten
df$rel <- as.numeric(prop.table(table(noten)))

# kumulierte relative
df$relkum <- cumsum(df$rel)

# umbenennen
colnames(df) <- c("Note", "Haeufig", "Hkum", "Relativ", "Rkum")

# anzeigen
df
```

:::


::: {.callout-tip}
## c) Stellen Sie die relativen Häufigkeiten als ausreichend beschriftetes Säulendiagramm dar.

```{r}
#| label: LoesungAB07c
#| warning: false
#| layout-ncol: 2
# Rbase
barplot(prop.table(table(noten)),
        col="steelblue",
        xlab="Abschlussnote",
        ylab="relative Häufigkeit")

# ggplot()
library(ggplot2)
ggplot(df, aes(x=Note, y=Relativ)) +
  geom_bar(stat="identity", fill="steelblue", color="black") +
  xlab("Abschlussnote") +
  ylab("relative Häufigkeit")
```

:::





### Lösung zur Aufgabe [-@sec-AAB08] Modulnoten {#sec-LAB08}

::: {.callout-tip}
## a) Übertragen Sie die Daten mittels der `rep()`-Funktion in `R`

```{r}
#| label: LoesungAB08a
#| warning: false
# überführe mittels rep()
noten <- c( rep("1+",1),  rep("1", 3),  rep("1-", 2),
            rep("2+",7),  rep("2", 12), rep("2-", 15),
            rep("3+",13), rep("3", 6),  rep("3-", 5),
            rep("4+",4),  rep("4", 4),  rep("nb", 4))

# überführe in ordinalen Factor
noten <- factor(noten, ordered=TRUE, 
                levels = c("1+", "1", "1-", "2+", "2", "2-",
                           "3+", "3", "3-", "4+", "4", "nb")
                )
```

:::


::: {.callout-tip}
## b) erstellen Sie eine vollständige Häufigkeitstabelle, ohne dabei die Funktion `jgsbook::freqTable()` zu verwenden.

```{r}
#| label: LoesungAB08b
#| warning: false
# überführe in Datenframe
df <- as.data.frame(table(noten))

# kumuliere
df$Hkum <- cumsum(df$Freq)

# relative Häufigkeiten
df$rel <- as.numeric(prop.table(table(noten)))

# kumulierte relative
df$relkum <- cumsum(df$rel)

# umbenennen
colnames(df) <- c("Note", "Haeufig", "Hkum", "Relativ", "Rkum")

# anzeigen
df
```

:::



::: {.callout-tip}
## c) Stellen Sie die relativen Häufigkeiten als ausreichend beschriftetes Balkendiagramm (nicht Säulendiagramm) dar.

```{r}
#| label: LoesungAB08c
#| warning: false
#| layout-ncol: 2
# Rbase
barplot(prop.table(table(noten)),
        col="orchid",
        # schalte um auf "Balkendiagramm"
        horiz=TRUE,
        ylab="Modulnote",
        xlab="relative Häufigkeit")

# ggplot()
library(ggplot2)
ggplot(df, aes(y=Note, x=Relativ)) +
  geom_bar(stat="identity", fill="orchid", color="black") +
  ylab("Modulnote") +
  xlab("relative Häufigkeit")
```

:::


