# Lösungswege zu den Aufgaben für geübte Anwender:innen {#sec-LoesungGeuebt}

::: {.callout-note appearance="simple"}
Wenn Ihr `R`-Code eleganter ist als die hier präsentierten Lösungswege, dann freuen Sie sich! Wenn Sie meinen, Ihr Code sei zu klobig und umständlich, dann Kopf hoch: wenn er tut, was er soll, dann ist er genau richtig.
:::


## Lösungen zu Objekten in R {#sec-LoesungenGeuebtA}

### Lösung zur Aufgabe [-@sec-ABA01] Hogwarts-Kurse {#sec-LBA01}
::: {.callout-tip}
## a) Benutzen Sie die `tribble()`-Funktion, um die Daten in die Objekte `tab1` und `tab2` zu überführen.

```{r}
#| label: LoesungBA01a
#| paged.print: FALSE
library(tibble)
tab1 <- tribble(
    ~Hufflepuff,                  ~Slytherin,
  "Kräuterkunde",               "Zaubertränke", 
  "Pflege magischer Geschöpfe", "Zauberkunst",
  "Geschichte der Zauberei",    "Dunkle Künste", 
  "Alte Runen",                 "Legilimentik"
)

tab2 <- tribble(
  ~Gryffindor,                             ~Ravenclaw,
  "Verteidigung gegen die dunklen Künste", "Arithmantik", 
  "Zauberkunst",                           "Astronomie",
  "Verwandlung",                           "Verwandlung",
  "Besenflugunterricht", "Verteidigung gegen die dunklen Künste"
)
# anzeigen
tab1
tab2
```

:::


::: {.callout-tip}
## b) Fügen Sie `tab1` und `tab2` zu einem Objekt `Hogwarts` zusammen.

```{r}
#| label: LoesungBA01b
Hogwarts <- cbind(tab1, tab2)

# anzeigen
str(Hogwarts)
```

:::


::: {.callout-tip}
## c) Nutzen Sie die `mutate()`-Funktion, um die Datenklassen der Variablen anzupassen (Skalenniveau).

```{r}
#| label: LoesungBA01c
#| warning: false
library(dplyr)
Hogwarts <- Hogwarts %>% 
              mutate_if(is.character, as.factor)

# anzeigen
str(Hogwarts)
```

:::


::: {.callout-tip}
## d) Ändern Sie anschließend mit der `mutate()`-Funktion den Kurs "*Geschichte der Zauberei*" \newline in "*Geisterkunde*" um.

```{r}
#| label: LoesungBA01d
library(dplyr)
library(forcats)
Hogwarts <- Hogwarts %>% 
    mutate(Hufflepuff = fct_recode(Hufflepuff, 
                                   "Geisterkunde" = "Geschichte der Zauberei"))

# anzeigen
Hogwarts
```

:::


::: {.callout-tip}
## e) Die Daten liegen nicht im Tidy-Data-Format vor. Erzeugen Sie ein neues Objekt `Kurse` mit den Variablen `Haus` und `Kurs`.

```{r}
#| label: LoesungBA01e
library(tidyr)
Kurse <- Hogwarts %>% 
          pivot_longer(Hufflepuff:Ravenclaw,
                       names_to = "Haus",
                       values_to = "Kurs")
# anzeigen
Kurse
```

:::






### Lösung zur Aufgabe [-@sec-ABA02] Aufnahme und Entlassung {#sec-LBA02}
::: {.callout-tip}
## a) Laden Sie den Datensatz `Krankenhaus.RData` in Ihre R-Session.
```{r}
#| label: LoesungBA02a
#| eval: false
# Lese Daten ein
load("https://www.produnis.de/R/data/Krankenhaus.RData")
```

```{r}
#| label: LoesungBA02a2
#| include: false
load("data/Krankenhaus.RData")
```

```{r}
#| label: LoesungBA02a3
# anschauen
str(St.Gott.Hospital)
```

:::



::: {.callout-tip}
## b) Ein Variablenname enthält einen Tippfehler. Reparieren Sie auch die Datenklassen der Variablen. Entfernen Sie alle Einträge mit ungültigen Zeitstempeln.
```{r}
#| label: LoesungBA02b
#| warning: false
# Variable ALter korrigieren
library(dplyr)
kh <- St.Gott.Hospital %>% 
  select(Geschlecht, Alter = ALter, Aufnahme, Entlassung)
                 
# Datenklassen anpassen
# Geschlecht als Faktor
kh$Geschlecht <- factor(kh$Geschlecht)

# Erzeuge POSIX Zeitobjekte
# CET = Europäische Zeit
library(lubridate)
kh$Aufnahme <- ymd_hm(kh$Aufnahme, tz="CET")
kh$Entlassung <- ymd_hm(kh$Entlassung, tz="CET")

# anzeigen
str(kh)
```
Durch die Umwandlung der Aufnahme- und Entlassungsdaten sind die Datenreihen mit fehlerhaften oder unvollständigen Zeitstempeln in NAs umgewandelt worden.

```{r}
#| label: LoesungBA02b2
kh <- kh %>% 
  drop_na(Aufnahme, Entlassung)

# anschauen
glimpse(kh)
```

:::



::: {.callout-tip}
## c) Erstellen Sie die neue Variable `Liegedauer`, welche die Aufenthaltsdauer in Tagen beinhaltet.
```{r}
#| label: LoesungBA02c
# Liegedauer berechnen
# entweder...
kh$Liegedauer <- as_date(kh$Entlassung) - as_date(kh$Aufnahme)

# ...oder
kh$Liegedauer <- ceiling(difftime(kh$Entlassung, kh$Aufnahme, units="days"))

# anzeigen
head(kh$Liegedauer)
str(kh)
```

:::





::: {.callout-tip}
## d) Über welchen Zeitraum wurden die Daten erhoben?
```{r}
#| label: LoesungBA02d
erste <- min(kh$Aufnahme, na.rm=TRUE)
letzte <- max(kh$Entlassung, na.rm=TRUE)

# Zeitspanne in Tagen
as_date(letzte) - as_date(erste)

# Zeitspanne in Wochen
difftime(letzte, erste, units="weeks")

# Zeitspanne in Jahren
as.numeric(as_date(letzte) - as_date(erste)) / 365
```

:::



::: {.callout-tip}
## e) Klassieren Sie die Daten der Aufnahme in einer neuen Variable `Kalenderjahr`. 
```{r}
#| label: LoesungBA02e
#| warning: false
# cut ausprobieren
a <- cut.POSIXt(kh$Aufnahme, breaks="years")
head(a)

# lubridate::year() ist einfacher
a <- year(kh$Aufnahme)
head(a)

# in neue Variable schreiben
kh$Kalenderjahr <- year(kh$Aufnahme)

# anschauen
glimpse(kh)
```

:::


::: {.callout-tip}
## f) Klassieren Sie die Daten der Entlassung je mit einer neuen Variable `Wochentag` und `Monat`. 
```{r}
#| label: LoesungBA02f
#| warning: false
# Wochentag
kh$Wochentag <- wday(kh$Entlassung, label=TRUE)

# Monat
kh$Monat <- month(kh$Entlassung, label=TRUE)

# anschauen
glimpse(kh)
```

:::




### Lösung zur Aufgabe [-@sec-ABA03] SPSS Datensatz {#sec-LBA03}
::: {.callout-tip}
## a) `alteDaten.sav`

Dateien mit Endung `.sav` stammen von SPSS.
```{r}
#| label: LoesungBA03a
#| eval: false
# Lese Daten ein
c <- haven::read_sav("https://www.produnis.de/R/data/alteDaten-kurz.sav")
```

```{r}
#| label: LoesungBA03a2
#| include: false
c <- haven::read_sav("data/alteDaten-kurz.sav")
```

:::


::: {.callout-tip}
## b) Passen Sie die Datenklassen der Variablen entsprechend des Skalenniveaus an, indem Sie nur Funktionen aus der `R` Standardinstallation verwenden. Dabei sollen die Variablennamen als Labels erhalten bleiben.

```{r}
#| label: LoesungBA03b
# Datenklassen anschauen
str(c)

# Variable
head(c$Frage_1)
```

Die Daten sind gelabelt und scheinen ordinalskaliert zu sein.
```{r}
#| label: LoesungBA03b4
# Antwortlabels von Hand aufschreiben
c.labels <- c("nicht vorhanden", "stimme gar nicht zu", "stimme nicht zu", 
              "weiß nicht", "stimme zu", "stimme voll zu")  
# oder einfach
c.labels <- names(attr(c$Frage_1, "labels"))

# Variablenbezeichnung speichern
c.vars <- c(attr(c$Frage_1, "label"), attr(c$Frage_2, "label") ,
            attr(c$Frage_3, "label"), attr(c$Frage_4, "label"))

# Variablen in ordinale Faktoren umwandeln
c$Frage_1 <- factor(c$Frage_1, ordered=TRUE, levels=c(0:5))
c$Frage_2 <- factor(c$Frage_2, ordered=TRUE, levels=c(0:5))
c$Frage_3 <- factor(c$Frage_3, ordered=TRUE, levels=c(0:5))
c$Frage_4 <- factor(c$Frage_4, ordered=TRUE, levels=c(0:5))

# Levelnamen ändern
levels(c$Frage_1) <- c.labels
levels(c$Frage_2) <- c.labels
levels(c$Frage_3) <- c.labels
levels(c$Frage_4) <- c.labels

# Variabeln wieder labeln
attr(c$Frage_1, "label") <- c.vars[1]
attr(c$Frage_2, "label") <- c.vars[2]
attr(c$Frage_3, "label") <- c.vars[3]
attr(c$Frage_4, "label") <- c.vars[4]

# anschauen
str(c)
```

:::


::: {.callout-tip}
## c) Wiederholen Sie den Vorgang und verwenden dabei Funktionen aus dem `tidyverse`.

```{r}
#| label: LoesungBA03c
#| eval: false
# Lese Daten ein
c <- haven::read_sav("https://www.produnis.de/R/data/alteDaten-kurz.sav")
```

```{r}
#| label: LoesungBA03c2
#| include: false
c <- haven::read_sav("data/alteDaten-kurz.sav")
library(tidyverse)
```

```{r}
#| label: LoesungBA03c3
library(tidyverse)
# wandle die Antwortlabels in Factoren um
c <- c %>% 
  mutate(haven::as_factor(., ordered=TRUE))

# anzeigen
str(c)
```

:::























## Lösungen zu den Datensatzauswertungen {#sec-LoesungenGeuebtB}

### Lösung zur Aufgabe [-@sec-ABB01] Aufnahme und Entlassung {#sec-LBB01}
::: {.callout-tip}
## a) Laden Sie den Datensatz `Krankenhaus.RData` in Ihre R-Session, korrigieren Sie den Tippfehler der Variable `ALter`, reparieren Sie die Datenklassen der Variablen und entfernen Sie alle Einträge mit ungültigen Zeitstempeln. 

```{r}
#| label: LoesungBB01setupA
#| eval: false
# Lese Daten ein
load("https://www.produnis.de/R/data/Krankenhaus.RData")
```

```{r}
#| label: LoesungBB01setupB
#| include: false
load("data/Krankenhaus.RData")
```


```{r}
#| label: LoesungBB01a
#| warning: false
library(dplyr)
library(lubridate)
# repariere Typo und Datenklassen und
# entferne NAs
kh <- St.Gott.Hospital %>% 
  select(Geschlecht, Alter = ALter, Aufnahme, Entlassung) %>% 
  mutate(Geschlecht = factor(Geschlecht),
         Aufnahme = ymd_hm(Aufnahme, tz="CET"),
         Entlassung = ymd_hm(Entlassung, tz="CET")
         ) %>% 
  drop_na(Aufnahme, Entlassung)

# anzeigen
glimpse(kh)
```

:::



::: {.callout-tip}
## b) Plotten Sie die absoluten Häufigkeiten der Aufnahmen und Entlassungen pro Kalendertag. Was fällt Ihnen auf?

```{r}
#| label: LoesungBB01b
#| warning: false
library(ggplot2)
# Hilfsdatenframe mit Anzahl Aufnahmen pro Tag
Aufnahmen <- kh %>%
  group_by(as_date(Aufnahme)) %>%
  summarise(freq = n()) %>% 
  # Spalten umbenennen
  select(Datum = `as_date(Aufnahme)`, freq) %>% 
  # Variable "Typ" hinzufügen
  mutate(Typ="Aufnahme")

# Hilfsdatenframe mit Anzahl Entlassungen pro Tag
Entlassungen <- kh %>%
  group_by(as_date(Entlassung)) %>%
  summarise(freq = n()) %>% 
  select(Datum = `as_date(Entlassung)`, freq) %>% 
  mutate(Typ="Entlassung")

# Zusammenführen
df <- rbind(Aufnahmen, Entlassungen)

# Plotten
ggplot(df, aes(x=Datum, y=freq)) +
  geom_line(aes(color=Typ)) +
  labs(title = "Absolute Häufigkeit der Datumswerte",
       x = "Datum",
       y = "Absolute Häufigkeit") +
  theme_minimal()
```
Es fällt auf, dass für das Jahr 2019 keine Daten zur Verfügung stehen.
:::




::: {.callout-tip}
## c) Plotten Sie die durchschnittlichen (arithmetisches Mittel) absoluten Häufigkeiten an täglichen Aufnahmen und Entlassungen pro Wochentag. Was fällt Ihnen auf?

```{r}
#| label: LoesungBB01c
#| warning: false
# nochmal Hilfsdatenframe mit Anzahl Aufnahmen pro Tag
Aufnahmen <- kh %>%
  group_by(as_date(Aufnahme)) %>%
  summarise(freq = n()) %>% 
  # Spalten umbenennen
  select(Datum = `as_date(Aufnahme)`, freq) %>% 
  # Variable "Typ" hinzufügen
  mutate(Typ = "Aufnahme",
         # Wochentag hinzufügen
         Tag= wday(Datum, label=TRUE))


# Hilfsdatenframe mit Anzahl Entlassungen pro Tag
Entlassungen <- kh %>%
  group_by(as_date(Entlassung)) %>%
  summarise(freq = n()) %>% 
  select(Datum = `as_date(Entlassung)`, freq) %>% 
  mutate(Typ = "Entlassung",
         # Wochentag hinzufügen
         Tag = wday(Datum, label=TRUE))

# zusammenführen
Wochentage <- rbind(Aufnahmen, Entlassungen)

# absolute Häufigkeiten anzeigen
table(Wochentage$Typ, Wochentage$Tag)

# durchschnittliche Häufigkeiten
Wochentage  %>% 
  group_by(Typ, Tag) %>% 
  summarise(Mean = mean(freq))

# durchschnittliche (arith.) Häufigkeiten
ggplot(Wochentage, aes(x=Tag, y=freq, fill=Typ)) +
  stat_summary(fun=mean, geom="bar", position="dodge") 
```

An Sonn- und Montag gibt es deutlich mehr Aufnahmen als Entlassungen.
:::



::: {.callout-tip}
## d) Plotten Sie die durchschnittlichen absoluten Häufigkeiten an täglichen Aufnahmen und Entlassungen pro Monat sowie die absoluten Häufigkeiten pro Tagesstunde.

```{r}
#| label: LoesungBB01d
#| warning: false
# nochmal Hilfsdatenframe mit Anzahl Aufnahmen pro Monat
Aufnahmen <- kh %>%
  group_by(as_date(Aufnahme)) %>%
  summarise(freq = n()) %>% 
  # Spalten umbenennen
  select(Datum = `as_date(Aufnahme)`, freq) %>% 
  # Variable "Typ" hinzufügen
  mutate(Typ = "Aufnahme",
         # Monat hinzufügen
         Monat= month(Datum, label=TRUE))


# Hilfsdatenframe mit Anzahl Entlassungen pro Tag
Entlassungen <- kh %>%
  group_by(as_date(Entlassung)) %>%
  summarise(freq = n()) %>% 
  select(Datum = `as_date(Entlassung)`, freq) %>% 
  mutate(Typ = "Entlassung",
         # Monate hinzufügen
         Monat= month(Datum, label=TRUE))

# zusammenführen
Monate <- rbind(Aufnahmen, Entlassungen)

# absolute Häufigkeiten anzeigen
table(Monate$Typ, Monate$Monat)

# durchschnittliche Häufigkeiten
 Monate %>% 
  group_by(Typ,Monat) %>% 
  summarise(Median = median(freq))

# durchschnittliche (Median) Häufigkeiten
ggplot(Monate, aes(x=Monat, y=freq, fill=Typ)) +
  stat_summary(fun=median, geom="bar", position="dodge") 
```





Wiederholen wir nun den Vorgang für die Häufigkeiten pro Tagesstunde.
```{r}
#| label: LoesungBB01d1
#| warning: false
# nochmal Hilfsdatenframe mit Anzahl Aufnahmen pro Tagesstunde
kh$Aufnahmestunde <- hour(kh$Aufnahme)
kh$Entlassungstunde <- hour(kh$Entlassung)

Aufnahmen <- kh %>%
  group_by(Aufnahmestunde) %>%
  summarise(freq = n()) %>% 
  # Variable "Typ" hinzufügen
  mutate(Typ = "Aufnahme") %>% 
  select(Stunde = Aufnahmestunde, freq, Typ)


# Hilfsdatenframe mit Anzahl Entlassungen pro Tagesstunde
Entlassungen <- kh %>%
  group_by(Entlassungstunde) %>%
  summarise(freq = n()) %>% 
  # Variable "Typ" hinzufügen
  mutate(Typ = "Entlassungen") %>% 
  select(Stunde = Entlassungstunde, freq, Typ)

# zusammenführen
Stunden <- rbind(Aufnahmen, Entlassungen)

# absolute Häufigkeiten pro Tagesstunde
ggplot(Stunden, aes(x=Stunde, y=freq, fill=Typ)) +
  geom_col(position="dodge") 
```


:::


::: {.callout-tip}
## e) Erstellen Sie ein Poissionregressionsmodell für die Anzahl der täglichen Aufnahmen erklärt durch den Wochentag. Ist das Modell überdispersioniert? Wieviele Aufnahmen sind an einem Dienstag und an einem Sonntag zu erwarten?

```{r}
#| label: LoesungBB01e
#| warning: false
# nur Aufnahmen
dfA <- subset(Wochentage, Typ=="Aufnahme")

# "Tag" für Poisson vorbereiten
# ordered entfernen
dfA$Tag <- factor(dfA$Tag, ordered=FALSE)
# Montag als Basiswert
dfA$Tag <- relevel(dfA$Tag, "Mo")

# Poisson-Modell erstellen
fit <- glm(freq ~ Tag, data=dfA, family = poisson)

# Zusammenfassung des Modells
summary(fit)
```


```{r}
#| label: LoesungBB01eB
# alternative Zusammenfassung
sjPlot::tab_model(fit)
```


Testen wir, ob das Modell überdispersioniert ist.
```{r}
#| label: LoesungBB01e2
AER::dispersiontest(fit, trafo=1)
```
Der Test ist signifikant, d.h. das Modell **ist** überdispersioniert. Wir müssen das Modell daher anpassen:
```{r}
#| label: LoesungBB01e3
fit <- glm(freq ~ Tag, data=dfA, family = quasipoisson)
summary(fit)
```

\bigskip\ 

Mit dem neuen Modell können nun die Vorhersagen erfolgen.
```{r}
#| label: LoesungBB01e4
# Vorhersage Dienstag
predict(fit, list(Tag="Di"), type = "response")

# Vorhersage Sonntag
predict(fit, list(Tag="So"), type = "response")
```

:::



::: {.callout-tip}
## f) Fügen Sie den Monat als weiteren Prädiktor hinzu. Wird das Modell dadurch besser? Wieviele Aufnahmen sind an einem Donnerstag im Mai zu erwarten, und wieviele im September?

```{r}
#| label: LoesungBB01f
#| warning: false
dfA$Monat <- month(dfA$Datum, label=TRUE)
dfA$Monat <- factor(dfA$Monat, ordered=FALSE)
dfA$Monat <- relevel(dfA$Monat, "Jan")

fit <- glm(freq ~ Tag + Monat, data=dfA, family="poisson")
summary(fit)

``` 

Das Modell hat einen größeren AIC-Wert als das alte.

Testen wir, ob das Modell überdispersioniert ist.
```{r}
#| label: LoesungBB01f2
AER::dispersiontest(fit, trafo=1)
```

Der Test ist signifikant, d.h. das Modell **ist** überdispersioniert. Wir müssen das Modell anpassen.

```{r}
#| label: LoesungBB01f3
fit <- glm(freq ~ Tag + Monat, data=dfA, family = quasipoisson)
summary(fit)
```

\bigskip\ 

Mit dem neuen Modell können wir nun die Vorhersagen treffen.
```{r}
#| label: LoesungBB01f4
# Vorhersagen
predict(fit, list(Tag="Do", Monat="Mai"), type = "response")
predict(fit, list(Tag="Do", Monat="Sep"), type = "response")
```
:::


::: {.callout-tip}
## g) Wie groß ist die Wahrscheinlichkeit, dass an einem Mittwoch im Mai 10 Patienten aufgenommen werden? 

```{r}
#| label: LoesungBB01g
#| warning: false
# Schätzen der mittleren Häufigkeit
mu <- predict(fit, list(Tag="Mi", Monat="Mai"), type = "response")

# Wahrscheinlichkeit für 10 Aufnahmen berechnen
dpois(10, lambda = mu)
``` 
Die Wahrscheinlichkeit liegt bei 2,3\%.
:::



::: {.callout-tip}
## h) Wie groß ist die Wahrscheinlichkeit, dass an einem Mittwoch im Mai zwischen 4 und 7 Patienten aufgenommen werden?

```{r}
#| label: LoesungBB01h
#| warning: false
# Schätzen der mittleren Häufigkeit
mu <- predict(fit, list(Tag="Mi", Monat="Mai"), type = "response")

# Wahrscheinlichkeit für 4 bis 7 Aufnahmen berechnen
# entweder
ppois(7, lambda=mu) - ppois(3, lambda=mu)

# oder
sum(dpois(4:7, lambda=mu))
``` 
Die Wahrscheinlichkeit liegt bei 60,76\%.
:::


::: {.callout-tip}
## i) Wie groß ist die Wahrscheinlichkeit, dass an einem Montag im Januar maximal 2 Patienten aufgenommen werden?

```{r}
#| label: LoesungBB01i
#| warning: false
# Schätzen der mittleren Häufigkeit
mu <- predict(fit, list(Tag="Mo", Monat="Jan"), type = "response")

# Wahrscheinlichkeit für maximal 2 Aufnahmen berechnen
ppois(2, lambda = mu)
``` 
Die Wahrscheinlichkeit liegt bei 0,98\%.
:::



::: {.callout-tip}
## j) Erzeugen Sie ein Histogramm des Alters der Probanden. Was fällt Ihnen auf? Korrigieren Sie wenn nötig die Daten. Ist das Alter der Probanden normalverteilt?

```{r}
#| label: LoesungBB01j
#| warning: false
# Histogramm mit Rbase
hist(kh$Alter)
# Wahrscheinlichkeit für maximal 2 Aufnahmen berechnen
ppois(2, lambda = mu)
``` 
Es fällt auf, dass es viele Probanden mit `Alter=0` gibt. Diese sollten in `NA` umgewandelt werden.

```{r}
#| label: LoesungBB01j2
kh$Alter[kh$Alter==0] <- NA

# Histogram wiederholen
hist(kh$Alter)

# Teste, ob Alter normalverteilt ist
ks.test(kh$Alter, "pnorm")
```
Der Test ist signifikant, das heisst, es liegt **keine** Normalverteilung vor.
:::



::: {.callout-tip}
## k) Stellen Sie das Alter der Männern und Frauen tabellarisch und graphisch dar. Unterscheidet sich das Alter der Probanden zwischen Männern und Frauen? 

```{r}
#| label: LoesungBB01k
#| warning: false
# Tabellarisch
kh %>%
  group_by(Geschlecht) %>%
  drop_na(Alter) %>%
  summarise(Min = min(Alter),
            Q1 = quantile(Alter, probs=0.25, type=6),
            Median = median(Alter),
            Mittel = mean(Alter),
            Q3 = quantile(Alter, probs=0.75, type=6),
            Max = max(Alter))


# graphisch
boxplot(Alter ~ Geschlecht, data=kh)
``` 
Männer und Frauen unterscheiden sich nicht hinsichtlich des Alters.
:::


::: {.callout-tip}
## l) Ist der Unterschied signifikant? 

```{r}
#| label: LoesungBB01l
#| warning: false
# subsets vorbereiten
m <- subset(kh, Geschlecht=="m")
w <- subset(kh, Geschlecht=="w")

# keine Normalverteilung = kein t.Test
wilcox.test(m$Alter, w$Alter)
``` 
Der Test ist nicht signifikant, es liegt kein Unterschied vor. 
:::




::: {.callout-tip}
## m) Ab welchem Alter sind 10\% der Männer älter als dieser Wert?

```{r}
#| label: LoesungBB01m
# nur Männer
m <- subset(kh, Geschlecht=="m")
# beim 90. Perzentil liegen 10% der Werte darüber
quantile(m$Alter, 0.9, na.rm=TRUE, type=6)
``` 
Es sind 10\% der Männer älter als 86 Jahre.
:::



::: {.callout-tip}
## n) Ab welchem Alter sind 80\% der Frauen jünger als dieser Wert?

```{r}
#| label: LoesungBB01n
# nur Frauen
w <- subset(kh, Geschlecht=="w")
# beim 90. Perzentil liegen 10% der Werte darüber
quantile(w$Alter, 0.8, na.rm=TRUE, type=6)
``` 
Es sind 80\% der Frauen jünger als 83 Jahre.
:::


::: {.callout-tip}
## o) Wie groß ist die mittlere Liegedauer in Tagen? Stellen Sie die Liegedauer mittels Kennwerten sowie graphisch dar. Was fällt Ihnen auf?

```{r}
#| label: LoesungBB01o
# Liegedauer berechnen
kh$Liegedauer <- as_date(kh$Entlassung) - as_date(kh$Aufnahme)
# mittlere Liegedauer, Median
mean(kh$Liegedauer)
# mittlere Liegedauer, Median
median(kh$Liegedauer)

# Tabellarische Darstellung
summary(as.numeric(kh$Liegedauer))

# graphische Darstellung
boxplot(kh$Liegedauer)
hist(as.numeric(kh$Liegedauer))
``` 
Es fällt auf, dass sehr viele Ausreißer enthalten sind.
:::


::: {.callout-tip}
## p) Wie viel Prozent der Patienten haben eine Liegedauer von mehr als 7 Tagen?

```{r}
#| label: LoesungBB01p
sum(kh$Liegedauer > 7) / length(kh$Liegedauer)
``` 
Im Datensatz haben 37,23 \% der Patienten eine Liegedauer von mehr als 7 Tagen.
:::


::: {.callout-tip}
## q) Unterscheiden sich Männer und Frauen hinsichtlich der Liegedauer? Stellen Sie den Unterschied ebenfalls tabellarisch und graphisch dar.

```{r}
#| label: LoesungBB01q
# Tabellarische Darstellung
kh %>%
  group_by(Geschlecht) %>%
  summarise(Min = min(Liegedauer),
            Q1 = quantile(Liegedauer, probs=0.25, type=6),
            Median = median(Liegedauer),
            Mittel = mean(Liegedauer),
            Q3 = quantile(Liegedauer, probs=0.75, type=6),
            Max = max(Liegedauer))

# graphische Darstellung
boxplot(Liegedauer ~ Geschlecht, data=kh)
``` 
Es ist kein Unterschied erkennbar.
:::



::: {.callout-tip}
## r) Ist der Unterschied der Liegedauer zwischen Männern und Frauen signifikant?

```{r}
#| label: LoesungBB01r
#| warning: false
# Teste auf Normalverteilung
ks.test(kh$Liegedauer, "pnorm")
```
Der Test ist signifikant, d.h. es liegt **keine** Normalverteilung vor. Als Signifikanztest ist daher der Mann-Whitney-U-Test durchzuführen

```{r}
#| label: LoesungBB01r2
# Vorbereitung
kh$Liegedauer <- as.numeric(kh$Liegedauer)
m <- subset(kh, Geschlecht=="m")
w <- subset(kh, Geschlecht=="w")

# Mann-Whitney-U-Test
wilcox.test(w$Liegedauer, m$Liegedauer)
``` 
Das Ergebnis ist signifikant. Es scheint doch einen Unterschied zwischen Männern und Frauen zu geben.
:::









### Lösung zur Aufgabe [-@sec-ABB02] Lungenkapazität {#sec-LBB02}
::: {.callout-tip}
## a) Laden Sie den Datensatz `lungcap` in Ihre R-Session.

```{r}
#| label: LoesungBB02setupA
# aktiviere den Datensatz
library(GLMsData)
data("lungcap")

# anschauen
str(lungcap)
```

:::


::: {.callout-tip}
## b) Erzeugen Sie eine neue Variable, welche die Körpergröße in Zentimetern enthält (1 Zoll =  2,54cm)

```{r}
#| label: LoesungBB02b
lungcap$Körpergröße <- lungcap$Ht*2.54

# anschauen
str(lungcap)
```

:::


::: {.callout-tip}
## c) Plotten Sie nebeneinander die Boxplots der Lungenkapazität nichtrauchenden und rauchenden Kindern. Legt das Diagramm einen Zusammenhang nahe?

```{r}
#| label: LoesungBB02c
boxplot(lungcap$FEV ~ lungcap$Smoke,
        col=c("darkgreen", "orchid"))
```
Es scheint, als ob rauchende Kinder eine größere Lungenkapazität hätten.
:::

::: {.callout-tip}
## d) Führen Sie einen Signifikanztest durch, um zu überprüfen, ob sich die Lungenkapazitäten in Abhängigkeit zu `Smoke` unterscheidet.

```{r}
#| label: LoesungBB02d
# Prüfe auf Normalverteilung
shapiro.test(lungcap$FEV)
```
Der Test ist signifikant, d.h. `FEV` ist nicht normalverteilt. Wir müssen daher den Mann-Whitney-U-Test verwenden.
```{r}
#| label: LoesungBB02d2
raucher <- subset(lungcap, Smoke==1)
nraucher <- subset(lungcap, Smoke==0)
wilcox.test(raucher$FEV, nraucher$FEV, alternative = "greater")
```
Der Test ist signifikant. Die Raucher haben eine größere Lungenkapazität als Nichtraucher.

:::



::: {.callout-tip}
## e) Erzeugen Sie eine Punktwole des Lungenvolumens und des Alters. Legt das Diagramm einen Zusammenhang nahe?

```{r}
#| label: LoesungBB02e
plot(lungcap$Age, lungcap$FEV, col="skyblue2")
```
Es scheint einen linearen Zusammenhang zwischen dem Alter und der Lungenkapazität zu geben.
:::



::: {.callout-tip}
## f) Erzeugen Sie eine Punktwole des Lungenvolumens und der Körpergröße. Legt das Diagramm einen Zusammenhang nahe?

```{r}
#| label: LoesungBB02f
plot(lungcap$Körpergröße, lungcap$FEV, col="thistle")
```
Es scheint einen linearen Zusammenhang zwischen der Körpergröße und der Lungenkapazität zu geben.
:::



::: {.callout-tip}
## g) Welches Regressionsmodell ist am besten geeignet, um `FEV erklärt durch Alter` zu bestimmen?

```{r}
#| label: LoesungBB02g
jgsbook::compare.lm(lungcap$FEV, lungcap$Age)
```
Am besten geeignet ist ein Potenzmodell.

:::


::: {.callout-tip}
## h) Welches Regressionsmodell ist am besten geeignet, um `FEV erklärt durch Körpergröße` zu bestimmen?

```{r}
#| label: LoesungBB02h
jgsbook::compare.lm(lungcap$FEV, lungcap$Körpergröße)
```
Am besten geeignet ist ein exponentielles Modell. Dabei ist R^2^ mit 0,79 größer als beim Potenzmodell des Alters (0,63).
Die Lungenkapazität wird am besten durch die Körpergröße erklärt.
:::


::: {.callout-tip}
## i) Berechnen Sie das Modell, welches `FEV` am besten erklärt.

```{r}
#| label: LoesungBB02i
# exponentielles Modell erstellen
fit <- lm(log(FEV) ~ Körpergröße, data=lungcap)
summary(fit)
```
:::



::: {.callout-tip}
## j) Plotten Sie eine Punktwolke, mit `FEV` auf der Y-Achse, und dem besten Prädiktor auf der X-Achse. Färben Sie die Daten mittels der Variable `Smoke`. Fügen Sie anschließend Ihre Modelllinie dem Plot hinzu.

```{r}
#| label: LoesungBB02j
#| layout-ncol: 2
# Subsets
raucher <- subset(lungcap, Smoke==1)
nraucher <- subset(lungcap, Smoke==0)

#-- Hilfswert für Modellinie
helper <- jgsbook::compare.lm(lungcap$FEV, lungcap$Körpergröße, predict=TRUE)

# plot()
plot(nraucher$Körpergröße, nraucher$FEV, col="darkgreen", 
     xlab="Körpergröße", ylab="Lungenkapazität")
points(raucher$Körpergröße, raucher$FEV, col="orchid", pch=19)
lines(helper$pred.x, helper$expo, col="blue", lwd=4)

#--------
# ggplot()
#---------
ggplot(lungcap, aes(x=Körpergröße, y=FEV)) +
  geom_point(aes(color=factor(Smoke))) +
  scale_color_manual(values=c("darkgreen", "orchid")) +
  geom_line(data=helper, aes(x=pred.x, y=expo), color="blue")
```
:::



::: {.callout-tip}
## k) Fügen Sie `Smoke`, `Age` und `Gender` als weitere Prädiktor dem Modell hinzu. Hat Rauchen einen Einfluss auf `FEV`?

```{r}
#| label: LoesungBB02k
# exponentielles Modell um "Smoke", "Age" und "Gender" erweitern
fit  <- lm(log(FEV) ~ Körpergröße + Age + Gender + Smoke, data=lungcap)
summary(fit)
```
Alle Prädiktoren sind signifikant. Der Beitrag von `Smoke` ist negativ. Dies spricht dafür, dass Rauchen die Lungenkapazität verschlechtert.

```{r}
#| label: LoesungBB02k2
# Modelle vergleichen
fit0 <- lm(log(FEV) ~ Körpergröße, data=lungcap)
# R^2 vergleichen
summary(fit0)$r.squared - summary(fit)$r.squared 
```
Durch Hinzunahme der Prädiktoren verbessert sich R^2^, aber nur minimal.
:::









### Lösung zur Aufgabe [-@sec-ABB03] Brustkrebs {#sec-LBB03}
::: {.callout-tip}
## a) Importieren Sie den Datensatz in Ihre R-Session und machen Sie sich mit dem Datensatz vertraut.

```{r}
#| label: LoesungBB03setupA
#| eval: false
# lade den Datensatz
breast <- haven::read_sav("https://www.produnis.de/R/data/breast.sav")
```


```{r}
#| label: LoesungBB03setupB
#| include: false
# lade den Datensatz
breast <-haven::read_sav("data/breast.sav")
```


```{r}
#| label: LoesungBB03a
# anschauen
head(breast)
str(breast)
```

:::


::: {.callout-tip}
## b) Klassieren Sie die Variablen

```{r}
#| label: LoesungBB03b
# klassieren
library(dplyr)
df <- breast %>%
  mutate(tumorK = cut(pathsize, breaks= c(0,2,5,Inf)),
         lymphK = cut(lnpos, breaks=c(0, 1, Inf), right=FALSE, 
                      labels=c("nein", "ja")),
         oestroK = cut(er, breaks=c(0, 1, Inf), right=FALSE, 
                      labels=c("negativ", "positiv")),
         progesK = cut(pr, breaks=c(0, 1, Inf), right=FALSE, 
                      labels=c("negativ", "positiv"))
         )
```

:::



::: {.callout-tip}
## c) Kodieren Sie die Variable `histgrad` um, so dass korrekte `NA`s enthalten sind.

```{r}
#| label: LoesungBB03c
# klassieren
head(df$histgrad)
```

Alle Werte "4" entsprechen `NA`s.

```{r}
#| label: LoesungBB03c2
# klassieren
df <- df %>%
  mutate(histgrad = replace(histgrad, histgrad == 4,NA),
         histgrad = factor(histgrad))
```
:::



::: {.callout-tip}
## d) Erstellen Sie ein Überlebenszeitmodell `status erklärt durch time` und geben Sie die Überlebenstafel sowie die Kaplan-Meier-Plots der kumulierten Überlebenswahrscheinlichkeiten aus.

```{r}
#| label: LoesungBB03d
# Das Gesamtmodell lässt sich nun so darstellen:
library(survival)
survival <- Surv(df$time, df$status)
km_fit   <- survfit(survival ~ 1, data=df)
summary(km_fit)
```

Die Plots können klassisch mit `plot(fit)` erzeugt werden, oder mittels `autoplot()` und `ggsurvplot()`.
```{r}
#| label: LoesungBB03d2
#| layout-ncol: 2
#| warning: false
library(ggplot2)
library(ggfortify) # für autoplot
autoplot(km_fit)
survminer::ggsurvplot(km_fit, pval=T)
```

:::




::: {.callout-tip}
## e) Gruppieren Sie Ihr Modell mit dem zuvor klassierten Variablen und plotten Sie jeweils die Kaplan-Meier-Kurven.

```{r}
#| label: LoesungBB03e
#| layout-ncol: 2
# Tumorgröße
km_fit <- survfit(survival ~ tumorK, data=df)
autoplot(km_fit, main="Tumorgröße")

# Lymphknoten
km_fit <- survfit(survival ~ lymphK, data=df)
autoplot(km_fit, main="Lymphknoten")

# Östrogenstatus
km_fit <- survfit(survival ~ oestroK, data=df)
autoplot(km_fit, main="Östrogenstatus")

# Progesteronstatus
km_fit <- survfit(survival ~ progesK, data=df)
autoplot(km_fit, main="Progesteronstatus")

# histologischer Grad
km_fit <- survfit(survival ~ histgrad, data=df)
autoplot(km_fit, main="histologischer Grad")

# Gesamtmodell
km_fit <- survfit(survival ~ 1, data=df)
autoplot(km_fit, main="Gesamtmodell")
```


:::



::: {.callout-tip}
## f) Führen Sie eine Cox-Regression auf das Überleben durch, wobei die klassierten Werte der Tumorgröße, des Lymphknotenbefalls, des Östrogen- und Progesteronstatus sowie des histologischen Grades als Prädiktoren verwendet werden. Stellen Sie Ihre Ergebnisse als Forste-Plot dar.

```{r}
#| label: LoesungBB03f
## Cox-Regression
cox <- survival::coxph(survival ~ tumorK + lymphK + histgrad + oestroK + progesK, data=df)
# Modell ausgeben
cox

```

Die Spalte `exp(coef)` entspricht der Hazard-Ratio, mit welcher Richtung und Stärke des jeweiligen
Einflusses interpretiert werden kann.

```{r}
#| label: LoesungBB03f2
#| warning: false
# Forest-Plot
forestmodel::forest_model(cox)
```

:::


